<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'><head><title>/home/rosejn/projects/icalendar/lib/icalendar/parser.rb - C0 code coverage information</title><style type='text/css'>body { background-color: rgb(240, 240, 245); }</style><style type='text/css'>span.marked {
 background-color: rgb(185, 200, 200);
 display: block;
}
span.inferred {
 background-color: rgb(170, 185, 185);
 display: block;
}
span.overview {
 border-bottom: 8px solid black;
}
div.overview {
 border-bottom: 8px solid black;
}
body {
 font-family: verdana, arial, helvetica;
}
div.footer {
 font-size: 68%;
 margin-top: 1.5em;
}
h1, h2, h3, h4, h5, h6 {
 margin-bottom: 0.5em;
}
h5 {
 margin-top: 0.5em;
}
.hidden {
 display: none;
}
div.separator {
 height: 10px;
}
table tr td, table tr th {
 font-size: 68%;
}
td.value table tr td {
 font-size: 11px;
}
table.percent_graph {
 height: 12px;
 border: #808080 1px solid;
 empty-cells: show;
}
table.percent_graph td.covered {
 height: 10px;
 background: #00f000;
}
table.percent_graph td.uncovered {
 height: 10px;
 background: #e00000;
}
table.percent_graph td.NA {
 height: 10px;
 background: #eaeaea;
}
table.report {
 border-collapse: collapse;
 width: 100%;
}
table.report td.heading {
 background: #dcecff;
 border: #d0d0d0 1px solid;
 font-weight: bold;
 text-align: center;
}
table.report td.heading:hover {
 background: #c0ffc0;
}
table.report td.text {
 border: #d0d0d0 1px solid;
}
table.report td.value {
 text-align: right;
 border: #d0d0d0 1px solid;
}
</style><style type='text/css'>span.run0 {
  background-color: rgb(178, 204, 255);
  display: block;
}
span.run1 {
  background-color: rgb(178, 206, 255);
  display: block;
}
span.run2 {
  background-color: rgb(178, 209, 255);
  display: block;
}
span.run3 {
  background-color: rgb(178, 211, 255);
  display: block;
}
span.run4 {
  background-color: rgb(178, 214, 255);
  display: block;
}
span.run5 {
  background-color: rgb(178, 218, 255);
  display: block;
}
span.run6 {
  background-color: rgb(178, 220, 255);
  display: block;
}
span.run7 {
  background-color: rgb(178, 223, 255);
  display: block;
}
span.run8 {
  background-color: rgb(178, 225, 255);
  display: block;
}
span.run9 {
  background-color: rgb(178, 228, 255);
  display: block;
}
span.run10 {
  background-color: rgb(178, 232, 255);
  display: block;
}
span.run11 {
  background-color: rgb(178, 234, 255);
  display: block;
}
span.run12 {
  background-color: rgb(178, 237, 255);
  display: block;
}
span.run13 {
  background-color: rgb(178, 239, 255);
  display: block;
}
span.run14 {
  background-color: rgb(178, 242, 255);
  display: block;
}
span.run15 {
  background-color: rgb(178, 246, 255);
  display: block;
}
span.run16 {
  background-color: rgb(178, 248, 255);
  display: block;
}
span.run17 {
  background-color: rgb(178, 251, 255);
  display: block;
}
span.run18 {
  background-color: rgb(178, 253, 255);
  display: block;
}
span.run19 {
  background-color: rgb(178, 255, 253);
  display: block;
}
span.run20 {
  background-color: rgb(178, 255, 249);
  display: block;
}
span.run21 {
  background-color: rgb(178, 255, 247);
  display: block;
}
span.run22 {
  background-color: rgb(178, 255, 244);
  display: block;
}
span.run23 {
  background-color: rgb(178, 255, 242);
  display: block;
}
span.run24 {
  background-color: rgb(178, 255, 239);
  display: block;
}
span.run25 {
  background-color: rgb(178, 255, 235);
  display: block;
}
span.run26 {
  background-color: rgb(178, 255, 233);
  display: block;
}
span.run27 {
  background-color: rgb(178, 255, 230);
  display: block;
}
span.run28 {
  background-color: rgb(178, 255, 228);
  display: block;
}
span.run29 {
  background-color: rgb(178, 255, 225);
  display: block;
}
span.run30 {
  background-color: rgb(178, 255, 221);
  display: block;
}
span.run31 {
  background-color: rgb(178, 255, 219);
  display: block;
}
span.run32 {
  background-color: rgb(178, 255, 216);
  display: block;
}
span.run33 {
  background-color: rgb(178, 255, 214);
  display: block;
}
span.run34 {
  background-color: rgb(178, 255, 211);
  display: block;
}
span.run35 {
  background-color: rgb(178, 255, 207);
  display: block;
}
span.run36 {
  background-color: rgb(178, 255, 205);
  display: block;
}
span.run37 {
  background-color: rgb(178, 255, 202);
  display: block;
}
span.run38 {
  background-color: rgb(178, 255, 200);
  display: block;
}
span.run39 {
  background-color: rgb(178, 255, 197);
  display: block;
}
span.run40 {
  background-color: rgb(178, 255, 193);
  display: block;
}
span.run41 {
  background-color: rgb(178, 255, 191);
  display: block;
}
span.run42 {
  background-color: rgb(178, 255, 188);
  display: block;
}
span.run43 {
  background-color: rgb(178, 255, 186);
  display: block;
}
span.run44 {
  background-color: rgb(178, 255, 183);
  display: block;
}
span.run45 {
  background-color: rgb(178, 255, 179);
  display: block;
}
span.run46 {
  background-color: rgb(179, 255, 178);
  display: block;
}
span.run47 {
  background-color: rgb(182, 255, 178);
  display: block;
}
span.run48 {
  background-color: rgb(184, 255, 178);
  display: block;
}
span.run49 {
  background-color: rgb(187, 255, 178);
  display: block;
}
span.run50 {
  background-color: rgb(191, 255, 178);
  display: block;
}
span.run51 {
  background-color: rgb(193, 255, 178);
  display: block;
}
span.run52 {
  background-color: rgb(196, 255, 178);
  display: block;
}
span.run53 {
  background-color: rgb(198, 255, 178);
  display: block;
}
span.run54 {
  background-color: rgb(201, 255, 178);
  display: block;
}
span.run55 {
  background-color: rgb(205, 255, 178);
  display: block;
}
span.run56 {
  background-color: rgb(207, 255, 178);
  display: block;
}
span.run57 {
  background-color: rgb(210, 255, 178);
  display: block;
}
span.run58 {
  background-color: rgb(212, 255, 178);
  display: block;
}
span.run59 {
  background-color: rgb(215, 255, 178);
  display: block;
}
span.run60 {
  background-color: rgb(219, 255, 178);
  display: block;
}
span.run61 {
  background-color: rgb(221, 255, 178);
  display: block;
}
span.run62 {
  background-color: rgb(224, 255, 178);
  display: block;
}
span.run63 {
  background-color: rgb(226, 255, 178);
  display: block;
}
span.run64 {
  background-color: rgb(229, 255, 178);
  display: block;
}
span.run65 {
  background-color: rgb(233, 255, 178);
  display: block;
}
span.run66 {
  background-color: rgb(235, 255, 178);
  display: block;
}
span.run67 {
  background-color: rgb(238, 255, 178);
  display: block;
}
span.run68 {
  background-color: rgb(240, 255, 178);
  display: block;
}
span.run69 {
  background-color: rgb(243, 255, 178);
  display: block;
}
span.run70 {
  background-color: rgb(247, 255, 178);
  display: block;
}
span.run71 {
  background-color: rgb(249, 255, 178);
  display: block;
}
span.run72 {
  background-color: rgb(252, 255, 178);
  display: block;
}
span.run73 {
  background-color: rgb(255, 255, 178);
  display: block;
}
span.run74 {
  background-color: rgb(255, 252, 178);
  display: block;
}
span.run75 {
  background-color: rgb(255, 248, 178);
  display: block;
}
span.run76 {
  background-color: rgb(255, 246, 178);
  display: block;
}
span.run77 {
  background-color: rgb(255, 243, 178);
  display: block;
}
span.run78 {
  background-color: rgb(255, 240, 178);
  display: block;
}
span.run79 {
  background-color: rgb(255, 238, 178);
  display: block;
}
span.run80 {
  background-color: rgb(255, 234, 178);
  display: block;
}
span.run81 {
  background-color: rgb(255, 232, 178);
  display: block;
}
span.run82 {
  background-color: rgb(255, 229, 178);
  display: block;
}
span.run83 {
  background-color: rgb(255, 226, 178);
  display: block;
}
span.run84 {
  background-color: rgb(255, 224, 178);
  display: block;
}
span.run85 {
  background-color: rgb(255, 220, 178);
  display: block;
}
span.run86 {
  background-color: rgb(255, 218, 178);
  display: block;
}
span.run87 {
  background-color: rgb(255, 215, 178);
  display: block;
}
span.run88 {
  background-color: rgb(255, 212, 178);
  display: block;
}
span.run89 {
  background-color: rgb(255, 210, 178);
  display: block;
}
span.run90 {
  background-color: rgb(255, 206, 178);
  display: block;
}
span.run91 {
  background-color: rgb(255, 204, 178);
  display: block;
}
span.run92 {
  background-color: rgb(255, 201, 178);
  display: block;
}
span.run93 {
  background-color: rgb(255, 198, 178);
  display: block;
}
span.run94 {
  background-color: rgb(255, 196, 178);
  display: block;
}
span.run95 {
  background-color: rgb(255, 192, 178);
  display: block;
}
span.run96 {
  background-color: rgb(255, 189, 178);
  display: block;
}
span.run97 {
  background-color: rgb(255, 187, 178);
  display: block;
}
span.run98 {
  background-color: rgb(255, 184, 178);
  display: block;
}
span.run99 {
  background-color: rgb(255, 182, 178);
  display: block;
}
span.run100 {
  background-color: rgb(255, 178, 178);
  display: block;
}
</style></head><body><h3>C0 code coverage information generated on Sun May 21 00:51:53 CEST 2006</h3><hr /><pre><span class='marked'>Marked code looks like this.
This line is also marked as covered.
</span><span class='inferred'>Lines considered as run by rcov, but not reported by Ruby, look like this.
</span><span class='false'>Finally, here&apos;s a line marked as not executed.
</span></pre>    <table class='report'>
      <thead>
        <tr>
          <td class='heading'>Name</td>
          <td class='heading'>Total lines</td>
          <td class='heading'>Lines of code</td>
          <td class='heading'>Total coverage</td>
          <td class='heading'>Code coverage</td>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>
            <a href='-home-rosejn-projects-icalendar-lib-icalendar-parser_rb.html'>/home/rosejn/projects/icalendar/lib/icalendar/parser.rb</a>
          </td>
          <td class='value'>
            <tt>398</tt>
          </td>
          <td class='value'>
            <tt>398</tt>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt>67.8%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='68' />
                      <td class='uncovered' width='32' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
          <td>
            <table cellspacing='0' cellpadding='0' align='right'>
              <tr>
                <td>
                  <tt>54.2%</tt>&nbsp;</td>
                <td>
                  <table cellspacing='0' class='percent_graph' cellpadding='0' width='100'>
                    <tr>
                      <td class='covered' width='54' />
                      <td class='uncovered' width='46' />
                    </tr>
                  </table>
                </td>
              </tr>
            </table>
          </td>
        </tr>
      </tbody>
    </table><pre><span class="false">  1 =begin
  2   Copyright (C) 2005 Jeff Rose
  3   Copyright (C) 2005 Sam Roberts
  4 
  5   This library is free software; you can redistribute it and/or modify it
  6   under the same terms as the ruby language itself, see the file COPYING for
  7   details.
  8 =end
</span><span class="marked">  9 
 10 require 'date'
 11 require 'uri'
 12 
 13 module Icalendar
 14   class Parser &lt; Icalendar::Base
 15     # date = date-fullyear [&quot;-&quot;] date-month [&quot;-&quot;] date-mday
 16     # date-fullyear = 4 DIGIT
 17     # date-month = 2 DIGIT
 18     # date-mday = 2 DIGIT
 19     DATE = '(\d\d\d\d)-?(\d\d)-?(\d\d)'
 20 
 21     # time = time-hour [&quot;:&quot;] time-minute [&quot;:&quot;] time-second [time-secfrac] [time-zone]
 22     # time-hour = 2 DIGIT
 23     # time-minute = 2 DIGIT
 24     # time-second = 2 DIGIT
 25     # time-secfrac = &quot;,&quot; 1*DIGIT
 26     # time-zone = &quot;Z&quot; / time-numzone
 27     # time-numzome = sign time-hour [&quot;:&quot;] time-minute
 28     TIME = '(\d\d):?(\d\d):?(\d\d)(\.\d+)?(Z|[-+]\d\d:?\d\d)?'
 29 
 30     def initialize(src)
 31       @@logger.debug(&quot;New Calendar Parser&quot;)
 32 
 33       # Setup the parser method hash table
 34       setup_parsers()
 35 
 36       # Define the next line method different depending on whether
 37       # this is a string or an IO object so we can be efficient about
 38       # parsing large files...
 39 
 40       # Just do the unfolding work in one shot if its a whole string
 41       if src.respond_to?(:split)
 42         unfolded = []
 43 
 44         # Split into an array of lines, then unfold those into a new array
 45         src.split(/\r?\n/).each do |line|
 46 
 47           # If it's a continuation line, add it to the last.
 48           # If it's an empty line, drop it from the input.
 49           if( line =~ /^[ \t]/ )
</span><span class="false"> 50             unfolded &lt;&lt; unfolded.pop + line[1, line.size-1]
</span><span class="marked"> 51           elsif( line =~ /^$/ )
 52           else
 53             unfolded &lt;&lt; line
 54           end
 55         end
 56 
 57         @lines = unfolded
 58         @index = 0
 59 
 60         # Now that we are unfolded we can just iterate through the array.
 61         # Dynamically define next line for a string.
 62         def next_line
 63           if @index == @lines.size
 64             return nil
 65           else
 66             line = @lines[@index]
 67             @index += 1
 68             return line
 69           end
 70         end
 71 
 72         # If its a file we need to read and unfold on the go to save from reading
 73         # large amounts of data into memory.
 74       elsif src.respond_to?(:gets)
</span><span class="false"> 75         @file = src
 76         @prev_line = src.gets
 77         if !@prev_line.nil?
 78           @prev_line.chomp!
 79         end
 80 
 81         # Dynamically define next line for an IO object
 82         def next_line
 83           line = @prev_line
 84 
 85           if line.nil? 
 86             return nil 
 87           end
 88 
 89           # Loop through until we get to a non-continuation line...
 90           loop do
 91             nextLine = @file.gets
 92             if !nextLine.nil?
 93               nextLine.chomp!
 94             end
 95 
 96             # If it's a continuation line, add it to the last.
 97             # If it's an empty line, drop it from the input.
 98             if( nextLine =~ /^[ \t]/ )
 99               line &lt;&lt; nextLine[1, nextLine.size]
100             elsif( nextLine =~ /^$/ )
101             else
102               @prev_line = nextLine
103               break
104             end
105           end
106           line
107         end
</span><span class="marked">108       else
109         raise ArgumentError, &quot;CalendarParser.new cannot be called with a #{src.class} type!&quot;
110       end
111     end
112 
113     # Parse the calendar into an object representation
114     def parse
115       calendars = []
116 
117       # Outer loop for Calendar objects
118       while (line = next_line)
119         fields = parse_line(line)
120 
121         # Just iterate through until we find the beginning of a calendar object
122         if fields[:name] == &quot;BEGIN&quot; and fields[:value] == &quot;VCALENDAR&quot;
123           cal = parse_component
124           calendars &lt;&lt; cal
125         end
126       end
127 
128       calendars
129     end
130 
131     private
132 
133     # Parse a single VCALENDAR object
134     # -- This should consist of the PRODID, VERSION, option METHOD &amp; CALSCALE,
135     # and then one or more calendar components: VEVENT, VTODO, VJOURNAL, 
136     # VFREEBUSY, VTIMEZONE
137     def parse_component(component = Calendar.new)
138       while (line = next_line)
139         fields = parse_line(line)
140 
141         name = fields[:name].upcase
142 
143         # Although properties are supposed to come before components, we should
144         # be able to handle them in any order...
145         if name == &quot;END&quot;
146           break
147         elsif name == &quot;BEGIN&quot; # New component
148           case(fields[:value])
149           when &quot;VEVENT&quot; # Event
150             component.add_component parse_component(Event.new)
</span><span class="false">151           when &quot;VTODO&quot; # Todo entry
152             component.add_component parse_component(Todo.new)
153           when &quot;VALARM&quot; # Alarm sub-component for event and todo
154             component.add_component parse_component(Alarm.new)
155           when &quot;VJOURNAL&quot; # Journal entry
156             component.add_component parse_component(Journal.new)
157           when &quot;VFREEBUSY&quot; # Free/Busy section
158             component.add_component parse_component(Freebusy.new)
159           when &quot;VTIMEZONE&quot; # Timezone specification
160             component.add_component parse_component(Timezone.new)
161           when &quot;STANDARD&quot; # Standard time sub-component for timezone
162             component.add_component parse_component(Standard.new)
163           when &quot;DAYLIGHT&quot; # Daylight time sub-component for timezone
164             component.add_component parse_component(Daylight.new)
165           else # Uknown component type, skip to matching end
166             until ((line = next_line) == &quot;END:#{fields[:value]}&quot;); end
167             next
168           end
</span><span class="marked">169         else # If its not a component then it should be a property
170 
171           params = fields[:params]
172           value = fields[:value]
173 
174           # Lookup the property name to see if we have a string to
175           # object parser for this property type.
176           if @parsers.has_key?(name)
</span><span class="false">177             value = @parsers[name].call(name, params, value)
178           end
</span><span class="marked">179 
180           name = name.downcase
181 
182           # TODO: check to see if there are any more conflicts.
183           if name == 'class' or name == 'method'
</span><span class="false">184             name = &quot;ip_&quot; + name
185           end
</span><span class="marked">186 
187           # Replace dashes with underscores
188           name = name.gsub('-', '_')
189 
190           if component.multi_property?(name)
</span><span class="false">191             adder = &quot;add_&quot; + name
192             if component.respond_to?(adder)
193               component.send(adder, value, params)
194             else
195               raise(UnknownPropertyMethod, &quot;Unknown property type: #{adder}&quot;)
196             end
</span><span class="marked">197           else
198             if component.respond_to?(name)
199               component.send(name, value, params)
</span><span class="false">200             else
201               raise(UnknownPropertyMethod, &quot;Unknown property type: #{name}&quot;)
202             end
203           end
204         end  
205       end
</span><span class="marked">206 
207       component
208     end
209 
210     # 1*(ALPHA / DIGIT / &quot;=&quot;)
211     NAME    = '[-a-z0-9]+'
212 
213     # &lt;&quot;&gt; &lt;Any character except CTLs, DQUOTE&gt; &lt;&quot;&gt;
214     QSTR    = '&quot;[^&quot;]*&quot;'
215 
216     # Contentline
217     LINE = &quot;(#{NAME})(.*(?:#{QSTR})|(?:[^:]*))\:(.*)&quot;
218    
219     # *&lt;Any character except CTLs, DQUOTE, &quot;;&quot;, &quot;:&quot;, &quot;,&quot;&gt;
220     PTEXT   = '[^&quot;;:,]*'
221 
222     # param-value = ptext / quoted-string
223     PVALUE  = &quot;#{QSTR}|#{PTEXT}&quot;
224 
225     # param = name &quot;=&quot; param-value *(&quot;,&quot; param-value)
226     PARAM = &quot;;(#{NAME})(=?)((?:#{PVALUE})(?:,#{PVALUE})*)&quot;
227 
228     def parse_line(line)
229       unless line =~ %r{#{LINE}}i # Case insensitive match for a valid line
230         raise &quot;Invalid line in calendar string!&quot;
231       end
232 
233       name = $1.upcase # The case insensitive part is upcased for easier comparison...
234       paramslist = $2
235       value = $3
236 
237       # Parse the parameters
238       params = {}
239       if paramslist.size &gt; 1
240         paramslist.scan( %r{#{PARAM}}i ) do
241 
242         # parameter names are case-insensitive, and multi-valued
243         pname = $1
244         pvals = $3
245 
246         # If their isn't an '=' sign then we need to do some custom
247         # business.  Defaults to 'type'
248         if $2 == &quot;&quot;
</span><span class="false">249           pvals = $1
250           case $1
251           when /quoted-printable/i
252             pname = 'encoding'
253 
254           when /base64/i
255             pname = 'encoding'
256 
257           else
258             pname = 'type'
259           end
260         end
</span><span class="marked">261 
262         # Make entries into the params dictionary where the name
263         # is the key and the value is an array of values.
264         unless params.key? pname
265           params[pname] = []
266         end
267 
268         # Save all the values into the array.
269         pvals.scan( %r{(#{PVALUE})} ) do
270           if $1.size &gt; 0
271             params[pname] &lt;&lt; $1
272           end
273         end
274         end
275       end
276 
277       {:name =&gt; name, :value =&gt; value, :params =&gt; params}
278     end
279 
280     ## Following is a collection of parsing functions for various 
281     ## icalendar property value data types...  First we setup
282     ## a hash with property names pointing to methods...
283     def setup_parsers
284       @parsers = {}
285 
286       # Integer properties
287       m = self.method(:parse_integer)
288       @parsers[&quot;PERCENT-COMPLETE&quot;] = m
289       @parsers[&quot;PRIORITY&quot;] = m
290       @parsers[&quot;REPEAT&quot;] = m
291       @parsers[&quot;SEQUENCE&quot;] = m
292 
293       # Dates and Times
294       m = self.method(:parse_datetime)
295       @parsers[&quot;COMPLETED&quot;] = m
296       @parsers[&quot;DTEND&quot;] = m
297       @parsers[&quot;DUE&quot;] = m
298       @parsers[&quot;DTSTART&quot;] = m
299       @parsers[&quot;RECURRENCE-ID&quot;] = m
300       @parsers[&quot;EXDATE&quot;] = m
301       @parsers[&quot;RDATE&quot;] = m
302       @parsers[&quot;CREATED&quot;] = m
303       @parsers[&quot;DTSTAMP&quot;] = m
304       @parsers[&quot;LAST-MODIFIED&quot;] = m
305 
306       # URI's
307       m = self.method(:parse_uri)
308       @parsers[&quot;TZURL&quot;] = m
309       @parsers[&quot;ATTENDEE&quot;] = m
310       @parsers[&quot;ORGANIZER&quot;] = m
311       @parsers[&quot;URL&quot;] = m
312 
313       # This is a URI by default, and if its not a valid URI
314       # it will be returned as a string which works for binary data
315       # the other possible type.
316       @parsers[&quot;ATTACH&quot;] = m 
317 
318       # GEO
319       m = self.method(:parse_geo)
320       @parsers[&quot;GEO&quot;] = m
321 
322     end
323 
324     # Booleans
325     # NOTE: It appears that although this is a valid data type
326     # there aren't any properties that use it...  Maybe get
327     # rid of this in the future.
328     def parse_boolean(name, params, value)
</span><span class="false">329       if value.upcase == &quot;FALSE&quot;
330         false
331       else
332         true
333       end
334     end
</span><span class="marked">335 
336     # Dates, Date-Times &amp; Times
337     # NOTE: invalid dates &amp; times will be returned as strings...
338     def parse_datetime(name, params, value)
</span><span class="false">339       begin
340         DateTime.parse(value)
341       rescue Exception
342         value
343       end
344 
345     end
</span><span class="marked">346 
347     # Durations
348     # TODO: Need to figure out the best way to represent durations 
349     # so just returning string for now.
350     def parse_duration(name, params, value)
</span><span class="false">351       value
352     end
</span><span class="marked">353 
354     # Floats
355     # NOTE: returns 0.0 if it can't parse the value
356     def parse_float(name, params, value)
</span><span class="false">357       value.to_f
358     end
</span><span class="marked">359 
360     # Integers
361     # NOTE: returns 0 if it can't parse the value
362     def parse_integer(name, params, value)
</span><span class="false">363       value.to_i
364     end
</span><span class="marked">365 
366     # Periods
367     # TODO: Got to figure out how to represent periods also...
368     def parse_period(name, params, value)
</span><span class="false">369       value
370     end
</span><span class="marked">371 
372     # Calendar Address's &amp; URI's
373     # NOTE: invalid URI's will be returned as strings...
374     def parse_uri(name, params, value)
</span><span class="false">375       begin
376         URI.parse(value)
377       rescue Exception
378         value
379       end
380     end
</span><span class="marked">381 
382     # Geographical location (GEO)
383     # NOTE: returns an array with two floats (long &amp; lat)
384     # if the parsing fails return the string
385     def parse_geo(name, params, value)
</span><span class="false">386       strloc = value.split(';')
387       if strloc.size != 2 
388         return value
389       end
390 
391       val = []
392       val[0] = strloc[0].to_f
393       val[1] = strloc[1].to_f
394       val
395     end
396 
397   end
398 end
</span></pre><hr /><p><a href='http://validator.w3.org/check/referer'><img src='http://www.w3.org/Icons/valid-xhtml10' height='31' alt='Valid XHTML 1.0!' width='88' /></a><a href='http://jigsaw.w3.org/css-validator/check/referer'><img src='http://jigsaw.w3.org/css-validator/images/vcss' alt='Valid CSS!' style='border:0;width:88px;height:31px' /></a></p></body></html>
